<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>罗文迪的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-06T14:39:20.756Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>biaodigit</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>抓取和分析Node端性能</title>
    <link href="http://yoursite.com/2020/01/06/1/"/>
    <id>http://yoursite.com/2020/01/06/1/</id>
    <published>2020-01-06T14:37:55.000Z</published>
    <updated>2020-01-06T14:39:20.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做性能优化的时候关注的重点一般是web端的性能，但在有Node作为中间层使用的情况下Node端的性能同样需要去关注。</p><p>比如网络请求慢的情况，原因除了网速问题以外可能也是Node端编译时间较长。特别是对于SEO项目大部分请求都会在Node端进行，所以Node端请求的响应时间对FP/FCP会有很明显的影响</p><a id="more"></a><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>服务端的性能指标比较多，所以我们只需要关注RT和QPS这两个影响页面性能和服务器消耗的就行了</p><ul><li>RT：响应时长，系统对请求作出的响应时间(单次请求耗时)</li><li>QPS：单台机器每秒处理查询数量<br>QPS的统计方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPS = 总请求数 / ( 进程总数 * 请求时间 )</span><br></pre></td></tr></table></figure></li></ul><p>假如一个请求的RT从500ms降低到100ms，那么理论上QPS就可以提升4倍，以前需要五台机器才能扛住的流量现在只需要一台，这样可以在减少响应时间的时候同时减少服务器资源消耗</p><h2 id="抓取Node端性能"><a href="#抓取Node端性能" class="headerlink" title="抓取Node端性能"></a>抓取Node端性能</h2><p>那应该怎样去抓取Node端请求的RT呢，Node本身是自带分析profile的，但是它导出的是日志分析，不太好判断性能消耗点在什么地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      20</span><br><span class="line">Time taken for tests:   46.932 seconds</span><br><span class="line">Complete requests:      250</span><br><span class="line">Failed requests:        0</span><br><span class="line">Keep-Alive requests:    250</span><br><span class="line">Total transferred:      50250 bytes</span><br><span class="line">HTML transferred:       500 bytes</span><br><span class="line">Requests per second:    5.33 [#/sec] (mean)</span><br><span class="line">Time per request:       3754.556 [ms] (mean)</span><br><span class="line">Time per request:       187.728 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1.05 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%   3755</span><br><span class="line">  66%   3804</span><br><span class="line">  75%   3818</span><br><span class="line">  80%   3825</span><br><span class="line">  90%   3845</span><br><span class="line">  95%   3858</span><br><span class="line">  98%   3874</span><br><span class="line">  99%   3875</span><br><span class="line"> 100%   4225 (longest request)</span><br></pre></td></tr></table></figure><p>所以我们可以用<a href="https://www.npmjs.com/package/v8-profiler-next" target="_blank" rel="noopener">v8-profiler-next</a>，这个插件可以对CPU和堆内存进行抓取，因为我们想要的是请求耗时的数据所以只抓CPU就行了。</p><p>在开发环境下还需要使用<a href="https://www.npmjs.com/package/loadtest" target="_blank" rel="noopener">loadtest</a>压力测试工具做一次CPU密集计算获取耗时平均值。</p><p>以站群的首页请求为例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router</span></span><br><span class="line"><span class="comment">// 首页请求api</span></span><br><span class="line">router.get(<span class="string">'/api/home/movie-list'</span>, controller.home.getMovieList)</span><br><span class="line"><span class="comment">// cpu数据上报</span></span><br><span class="line">router.get(<span class="string">'/api/cpuprofile'</span>,controller.home.exportCPUProfile)</span><br><span class="line"></span><br><span class="line"><span class="comment">// controller/home</span></span><br><span class="line"><span class="keyword">const</span> profiler = <span class="built_in">require</span>(<span class="string">'v8-profiler-next'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">async</span> getMovieList(ctx) &#123;</span><br><span class="line">  <span class="keyword">return</span> ctx.helper.commonStr(&#123; ctx, <span class="attr">type</span>: “<span class="keyword">get</span>”, serverName: “home”, fnName: “getHomeList” &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async exportCPUProfile() &#123;</span><br><span class="line">    profiler.startProfiling(<span class="string">'CPU profile'</span>)</span><br><span class="line">    <span class="comment">//Stop Profiling after 60s</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> profile = profiler.stopProfiling()</span><br><span class="line">      profile.export()</span><br><span class="line">        .pipe(fs.createWriteStream(<span class="string">`cpuprofile-<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>.cpuprofile`</span>))</span><br><span class="line">        .on(<span class="string">'finish'</span>, () =&gt; profile.delete())</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'finish'</span>)</span><br><span class="line">    &#125;, <span class="number">60000</span>)</span><br><span class="line">    <span class="keyword">this</span>.ctx.body = &#123;</span><br><span class="line">      statue: <span class="string">'success'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// service/home</span></span><br><span class="line"><span class="keyword">async</span> getHomeList(opt: &#123; <span class="attr">domain</span>: string, <span class="attr">isAmp</span>: string &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; domain, isAmp &#125; = opt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> url = <span class="keyword">this</span>.ctx.helper.parseParam(&#123;</span><br><span class="line">      auth: <span class="keyword">this</span>.app.config.apiAuth,</span><br><span class="line">      domain</span><br><span class="line">    &#125;, API.MOVIE_HOME_LIST_URL)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> data: any = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.service.mc.getMC(url)</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      ..</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后开两个终端分别运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8083/api/cpuprofile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadtest http://127.0.0.1:8083/api/home/movie-list/?domain=movierulz.video&amp;&amp;isAmp=false -n 100</span><br></pre></td></tr></table></figure><p>结束抓取后导出的<code>.cpuprofile</code>文件我们是不能直接去看的，还要通过<strong>Chrome devtools</strong>提供的CPU分析页面展示抓取到的数据。<br><img src="/2020/01/06/1/3/01.png" alt="01.png"><br>进入<strong>JavaScript Profiler</strong>页面后点击<strong>Load</strong>按钮导入上面的profile文件就能得到分析结果。<br><img src="/2020/01/06/1/3/02.png" alt="02.png"><br>分析结果有两个指标：</p><ul><li><strong>Self Time</strong>: 函数调用所耗费的时间，仅包含函数本身的声明，不包含任何子函数的执行时间。</li><li><strong>Total Time</strong>: 函数调用所耗费的总时间，包含函数本身的声明及所有子函数执行时间</li></ul><p>所以只需要看<strong>Total Time</strong>即可，然后根据<strong>Total Time</strong>去定位问题作出具体的优化措施。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://yq.aliyun.com/articles/694994?spm=a2c4e.11155435.0.0.43da6154bJgrQM" target="_blank" rel="noopener">https://yq.aliyun.com/articles/694994?spm=a2c4e.11155435.0.0.43da6154bJgrQM</a><br>2.<a href="https://xiaozhuanlan.com/Nodejs-Guide/8209375641" target="_blank" rel="noopener">https://xiaozhuanlan.com/Nodejs-Guide/8209375641</a><br>3.<a href="https://juejin.im/entry/5a3b46676fb9a04512391cd1" target="_blank" rel="noopener">https://juejin.im/entry/5a3b46676fb9a04512391cd1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在做性能优化的时候关注的重点一般是web端的性能，但在有Node作为中间层使用的情况下Node端的性能同样需要去关注。&lt;/p&gt;
&lt;p&gt;比如网络请求慢的情况，原因除了网速问题以外可能也是Node端编译时间较长。特别是对于SEO项目大部分请求都会在Node端进行，所以Node端请求的响应时间对FP/FCP会有很明显的影响&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
