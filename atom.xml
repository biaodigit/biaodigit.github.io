<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>罗文迪的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-04T06:35:13.835Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>biaodigit</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Next.js心得</title>
    <link href="http://yoursite.com/2019/12/22/2/"/>
    <id>http://yoursite.com/2019/12/22/2/</id>
    <published>2019-12-22T09:51:01.000Z</published>
    <updated>2020-01-04T06:35:13.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="黑盒型框架"><a href="#黑盒型框架" class="headerlink" title="黑盒型框架"></a>黑盒型框架</h2><p>框架设计理念ZEIT团队并没有对外说过，但是国内的Node.js布道者i5ting对<a href="https://github.com/ykfe/egg-react-ssr/wiki/%E4%B8%8Enext.js%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E7%9A%84%E5%AF%B9%E6%AF%94#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">Next.js评价</a>是框架黑盒，可配置性差，这一点在使用Next.js的感受中是很符合的，这个特点可能对于ZEIT团队来说有他们考量，但是从工程应用的多样性角度来看尽量要求框架具备较高可配置性适配不同的业务，所以这个黑盒投入到业务开发后就会引发各种各种的问题</p><a id="more"></a><h2 id="与Egg-js结合使用"><a href="#与Egg-js结合使用" class="headerlink" title="与Egg.js结合使用"></a>与Egg.js结合使用</h2><p>Next.js官方github有一个example library，里面主要是Next.js与其他技术结合使用的一些demo，但没有与Egg.js结合的例子，而在Egg.js官方github有人提过<a href="https://github.com/eggjs/egg/issues/3393" target="_blank" rel="noopener">issue</a>Egg.js怎样去接入Next.js，官方给出的答复是Koa/Egg的底层实现与基于Express实现的Next有冲突，不建议两者结合使用。所以网上对如何把Egg.js和Next.js一起使用的资料比较稀缺，加大了开发难度</p><h2 id="无法按页面分割样式"><a href="#无法按页面分割样式" class="headerlink" title="无法按页面分割样式"></a>无法按页面分割样式</h2><p>在开发的时候由于VidMate Sites是多页应用，按预期是每个页面只需要加载对应页面的css文件和公共css文件，但是查看network的时候发现每一个页面都是加载同一个styles.css文件</p><p>经过查看Next的css插件<code>next-css</code><a href="https://github.com/zeit/next-plugins/blob/master/packages/next-css/css-loader-config.js" target="_blank" rel="noopener">源码</a>定位到问题在哪</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isServer) &#123;</span><br><span class="line">  config.optimization.splitChunks.cacheGroups.styles = &#123;</span><br><span class="line">    name: <span class="string">'styles'</span>,</span><br><span class="line">    test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`\\.+(<span class="subst">$&#123;[...fileExtensions].join(<span class="string">'|'</span>)&#125;</span>)$`</span>),</span><br><span class="line">    chunks: <span class="string">'all'</span>,</span><br><span class="line">    enforce: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面配置的含义是全部<code>fileExtensions</code>文件中引入的css文件全部抽取出来打包成<code>styles.css</code>， <code>fileExtensions</code>就是<code>webpack配置</code>中的<code>entry</code>这种做法对单页应用是很有用的，全部组件页面css文件集中成一个，原来的n个css文件请求减少至一个，但是对于多页应用来说这种分割方式是不适合的，因为跳转页面需要重新请求，这个时候需要做的是减少页面文件的体积，所以腾讯新闻使用styled-jsx应该也是这个原因</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用<code>styled-jsx</code>来解决，但是用<code>style-jsx</code>又会触发另外一个问题</p><h2 id="兼容AMP"><a href="#兼容AMP" class="headerlink" title="兼容AMP"></a>兼容AMP</h2><p>兼容AMP是目前使用Next最大的问题，因为这相当于把两个黑盒框架组合使用，难度是可想而知的</p><p>AMP也是一个对可配置性限制很大的框架，特别是对css只能嵌入不能引入，并且大小限制在50000Bytes内，然内嵌的自定义css要求以<code>&lt;style amp-custom&gt;.....&lt;/style&gt;</code>方式写入，如果缺少<code>amp-custom</code>就无法通过<code>amp validator</code></p><p>然后在内嵌全局初始化样式的时候Next打包文件并没有把<code>amp-custom</code>写入<code>style</code>标签中</p><p>现在使用<code>&lt;style jsx global&gt;...&lt;/style&gt;</code>初始化样式，但是在Next8.x版本中存在概率性无法加载的问题，目前在Next9.x demo中尝试使用</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h2 id="服务端样式渲染"><a href="#服务端样式渲染" class="headerlink" title="服务端样式渲染"></a>服务端样式渲染</h2><p>目前css是使用<code>styled-jsx</code>，但是服务端渲染是不会同时渲染样式，只会传到客户端后再把样式加载出来，所以这样会存在一个样式闪屏的情况，闪屏的时长根据全部包含css样式脚本并行加载时间决定<br><img src="/2019/12/22/2/style_01.png" alt="02.png"><br>所以一般的服务端渲染都是选择使用引入css文件然后挂载在<code>&lt;head&gt;...&lt;/head&gt;</code>中，这样dom渲染出来后可以马上拿到样式</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于样式闪屏的可以参考腾讯新闻在主页面加载前配一个闪屏，1s后闪屏消失主页样式全部加载完毕</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>还有其他较小的问题，比如</p><ol><li>生产环境和开发环境可能是2个分开的黑盒，比如：<ul><li>开发环境可以自定义 build 文件夹路径，但是生产环境无法识别必须使用 .next</li><li>上面提到的无法分割多页面css，在开发环境尝试自定义webpack分割是可行的，但是放到生产环境无法识别配置分割出来的文件，所以转向使用 styled-jsx</li></ul></li><li>文档偏指路性，只会告诉用户它支持这个配置，详细配置以及产生的问题要靠用户在github issue、stackoverflow、spectrum.chat等社区寻找你想要的答案</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;黑盒型框架&quot;&gt;&lt;a href=&quot;#黑盒型框架&quot; class=&quot;headerlink&quot; title=&quot;黑盒型框架&quot;&gt;&lt;/a&gt;黑盒型框架&lt;/h2&gt;&lt;p&gt;框架设计理念ZEIT团队并没有对外说过，但是国内的Node.js布道者i5ting对&lt;a href=&quot;https://github.com/ykfe/egg-react-ssr/wiki/%E4%B8%8Enext.js%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E7%9A%84%E5%AF%B9%E6%AF%94#%E6%80%BB%E7%BB%93&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next.js评价&lt;/a&gt;是框架黑盒，可配置性差，这一点在使用Next.js的感受中是很符合的，这个特点可能对于ZEIT团队来说有他们考量，但是从工程应用的多样性角度来看尽量要求框架具备较高可配置性适配不同的业务，所以这个黑盒投入到业务开发后就会引发各种各种的问题&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>搭建Next.js+Egg.js</title>
    <link href="http://yoursite.com/2019/12/07/1/"/>
    <id>http://yoursite.com/2019/12/07/1/</id>
    <published>2019-12-06T16:36:08.000Z</published>
    <updated>2020-01-04T06:36:11.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Next-js简介"><a href="#Next-js简介" class="headerlink" title="Next.js简介"></a>Next.js简介</h2><p>Next.js作为<a href="https://reactjs.org/docs/create-a-new-react-app.html#nextjs" target="_blank" rel="noopener">React官方钦定</a>的SSR轻量级框架，有以下几个特性：</p><ul><li>开箱即用，支持0配置开发</li><li>支持约定式路由</li><li>支持自定义服务端路由，可以配合其他Node框架使用</li><li>渐进式babel和webpack配置</li><li>支持客户端渲染</li><li>社区活跃，团队不太监</li><li>对前端新技术支持较为全面，比如AMP、TypeScript、PWA、Serverless等</li></ul><p>在Nemo FE以React为主要开发框架的前提下SEO项目重构选择Next.js就非常合适</p><a id="more"></a><h2 id="Next-js自定义配置"><a href="#Next-js自定义配置" class="headerlink" title="Next.js自定义配置"></a>Next.js自定义配置</h2><p>官方文档在自定义服务端路由的例子中给出了一个demo，可以给后面和Egg.js配置提供参考性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createServer &#125; = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; parse &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">const</span> next = <span class="built_in">require</span>(<span class="string">'next'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> app = next(&#123; dev &#125;)</span><br><span class="line"><span class="keyword">const</span> handle = app.getRequestHandler()</span><br><span class="line"></span><br><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parsedUrl = parse(req.url, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname, query &#125; = parsedUrl</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pathname === <span class="string">'/a'</span>) &#123;</span><br><span class="line">      app.render(req, res, <span class="string">'/b'</span>, query)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/b'</span>) &#123;</span><br><span class="line">      app.render(req, res, <span class="string">'/a'</span>, query)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle(req, res, parsedUrl)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码大概可以拆分成两个部分:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> app = next(&#123; dev &#125;)</span><br><span class="line"><span class="keyword">const</span> handle = app.getRequestHandler()</span><br></pre></td></tr></table></figure><p>1.对next进行实例化，缓存环境变量以及一个专门处理路由和静态资源的方法(这个方法原理和意义在<a href>Next.js源码解读——启动命令</a>中讲述过，这里不再赘述)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.当前期的实例和方法都准备好以后，下一步就是启动服务了，启动http服务之前先跑了一次<code>app.prepare</code>，而这个<code>app.prepare</code>是干什么用的呢，在这里可以先不急着去看prepare的源码，可以先去看看next官方脚手架是怎么跑起来的。</p><p>官方给出的命令配置如下：<br><img src="/2019/12/07/1/01.png" alt="01.png"><br>以<code>dev</code>为例，可以从next源码中找到对应的<code>cli/next-dev.ts</code>文件</p><blockquote><p>next-dev.ts</p></blockquote><p><img src="/2019/12/07/1/02.png" alt="02.png"><br>可以看到在<code>dev</code>启动命令同样调用了<code>app.prepare</code>这个方法，而前面那个<code>startServer</code>又是个什么东西，可以根据路径找到对应文件</p><blockquote><p>start-server.ts</p></blockquote><p><img src="/2019/12/07/1/03.png" alt="03.png"></p><p>看到这里就大概知道官方启动next的流程是先启动一个http服务，启动完后再去调用<code>app.prepare</code>方法，除了<code>dev</code>生产模式下的<code>start</code>也是同样流程，所以这个时候prepare内部是干什么的已经不需要去知道，源码怎么做这边自定义启动next就怎么做</p><p>至于是先创建http服务还是先跑<code>app.prepare</code>方法也不重要，只要在开始做路由匹配前都启动完成即可</p><h2 id="Egg-js自定义配置"><a href="#Egg-js自定义配置" class="headerlink" title="Egg.js自定义配置"></a>Egg.js自定义配置</h2><p>Egg.js自定义配置较简单，只需要在根目录新建一个<code>app.ts</code>，调用didLoad生命周期函数即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Application &#125; <span class="keyword">from</span> <span class="string">'egg'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">AppBootHook</span> </span>&#123;</span><br><span class="line">    public app: Application</span><br><span class="line">    <span class="keyword">constructor</span>(app: Application) &#123;</span><br><span class="line">        <span class="keyword">this</span>.app = app</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> didLoad() &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>disLoad</code>周期定义</p><blockquote><p>所有的配置已经加载完毕,可以用来加载应用自定义的文件，启动自定义的服务</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="搭建思路"><a href="#搭建思路" class="headerlink" title="搭建思路"></a>搭建思路</h3><p>Ok，在分析完Next.js和Egg.js的自定义配置过程后，下面开始思考下🤔怎么把这两个官方团队相互排斥的框架结合在一起做成自己想要的配置</p><p>先捋一下搭建思路：</p><ul><li>首先路由是由Egg控制而不是使用Next的约定式路由，因为契合SEO需求一个页面可能被多个路由使用，所以用Egg控制路由更合适</li><li>既然项目用Egg启动也就是Next需要自定义在Egg启动的时候实例化，实例化要做两件事情：<ul><li>1.自定义一个render方法然后挂载在上Egg上，因为View层渲染是由Next去完成，然后通过的Egg的Controller返回给客户端</li><li>2.上文提到Next有一个<code>getRequestHandler</code>的方法用于处理路由和静态文件，放到这里路由是不用处理因为这事是Egg做的，但是静态资源还是要由Next做的，所以也应该想办法把这个方法挂到Egg上</li></ul></li><li>考虑到SEO需求需要使用Google的<code>AMP</code>框架，鉴于之前使用Egg模版引擎<code>Nunjucks</code>在写H5页和AMP页的时候HTML和CSS都需要分开写&amp;&amp;打包，既然Next支持AMP，为了体现重构的价值争取用最少的代码实现一步到位</li></ul><p>大概就是这三点是整个搭建过程需要考虑的</p><h3 id="Egg-js-Next-js-Initialize-Combine"><a href="#Egg-js-Next-js-Initialize-Combine" class="headerlink" title="Egg.js+Next.js Initialize Combine"></a>Egg.js+Next.js Initialize Combine</h3><p>首先使用egg脚手架初始化项目</p><blockquote><p>npm init egg –type=simple</p></blockquote><p>按上面说的到的思路在Egg启动的时候对Next进行实例化，那么先来建一个<code>ssr.js</code>，对<code>next</code>的实例化主要分为3步：</p><ul><li><code>next</code>实例化，然后调用<code>prepare</code>方法</li><li>因为需要通过<code>next</code>生成<code>html模版</code>，已经不需要使用Egg的<code>render</code>方法，所以要自行封装<code>renderTsx</code>方法，方法内部调用<code>render</code>方法返回渲染好的<code>html模版</code></li><li>然后把<code>renderTsx</code>方法挂载到Egg的<code>ctx</code>上</li></ul><blockquote><p>server/ssr.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> next <span class="keyword">from</span> <span class="string">'next'</span></span><br><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// next实例化</span></span><br><span class="line">    <span class="keyword">const</span> nextServer = next(&#123; dev &#125;);</span><br><span class="line">    <span class="comment">// 缓存getRequestHander方法</span></span><br><span class="line">    <span class="keyword">const</span> requestHandler = nextServer.getRequestHandler();</span><br><span class="line">    <span class="comment">// 按照上面分析先调用prepare方法</span></span><br><span class="line">    <span class="keyword">await</span> nextServer.prepare();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> renderTsx = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 调用nextServer的render方法，里面传入的page路径和参数都通过在Egg端传入</span></span><br><span class="line">        <span class="keyword">const</span> html = <span class="keyword">await</span> nextServer.render(</span><br><span class="line">            ctx.req,</span><br><span class="line">            ctx.res,</span><br><span class="line">            <span class="string">`/<span class="subst">$&#123;options.page&#125;</span>`</span>,</span><br><span class="line">            options.props</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 模版挂载到body上</span></span><br><span class="line">        ctx.body = html;</span><br><span class="line">        <span class="keyword">return</span> html</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Object.defineProerty方法挂载renderTsx方法</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(app.context, <span class="string">'renderTsx'</span>, &#123;</span><br><span class="line">        writable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        value: renderTsx</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Object.defineProerty方法挂载requestHandler方法，在Egg中间件调用</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(app.context, <span class="string">'requestHandler'</span>, &#123;</span><br><span class="line">        writable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        value: requestHandler</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据Egg.js文档自定义Egg服务需要在根目录建一个<code>app.js</code>，并要默认导出一个类，然后引入刚才在<code>ssr.js</code>中封装的启动函数</p><blockquote><p>app.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SSR <span class="keyword">from</span> <span class="string">'./server/ssr'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (app) =&gt; &#123;</span><br><span class="line">    app.beforeStart(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">       <span class="keyword">await</span> SSR(app)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面说到<code>requestHandler</code>在挂载到<code>ctx</code>上后需要在中间件调用，为什么要在中间件调用呢，这个其实也是同构的原理之一，简单的说同构</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Next-js简介&quot;&gt;&lt;a href=&quot;#Next-js简介&quot; class=&quot;headerlink&quot; title=&quot;Next.js简介&quot;&gt;&lt;/a&gt;Next.js简介&lt;/h2&gt;&lt;p&gt;Next.js作为&lt;a href=&quot;https://reactjs.org/docs/create-a-new-react-app.html#nextjs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React官方钦定&lt;/a&gt;的SSR轻量级框架，有以下几个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开箱即用，支持0配置开发&lt;/li&gt;
&lt;li&gt;支持约定式路由&lt;/li&gt;
&lt;li&gt;支持自定义服务端路由，可以配合其他Node框架使用&lt;/li&gt;
&lt;li&gt;渐进式babel和webpack配置&lt;/li&gt;
&lt;li&gt;支持客户端渲染&lt;/li&gt;
&lt;li&gt;社区活跃，团队不太监&lt;/li&gt;
&lt;li&gt;对前端新技术支持较为全面，比如AMP、TypeScript、PWA、Serverless等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Nemo FE以React为主要开发框架的前提下SEO项目重构选择Next.js就非常合适&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Nodejs性能优化</title>
    <link href="http://yoursite.com/2019/12/07/3/"/>
    <id>http://yoursite.com/2019/12/07/3/</id>
    <published>2019-12-06T16:35:54.000Z</published>
    <updated>2020-01-04T06:49:18.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做页面性能优化的时候关注的重点一般是网络消耗，比如减少网络请求、降低资源大小等等，而优化JS代码执行时间其实也是一种非常不错的方式，尤其是对于SSR而言，执行代码的大部分时间都集中在服务端，所以JS本身的执行时间就变得非常重要。</p><p>比如一个请求的执行时间从30ms降到3ms, 假设有n个服务器请求，那么10台服务器才能扛住的流量现在1台服务器就能扛住，而且响应时间更短，响应时间更短意味着用户更快看到白屏</p><h2 id="服务端端性能指标"><a href="#服务端端性能指标" class="headerlink" title="服务端端性能指标"></a>服务端端性能指标</h2><p>服务端的性能指标有几个：RT、TPS、QPS、PV</p><h2 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h2><p>响应时长，系统对请求作出的响应时间(单次请求耗时)</p><p>通常来说一个请求在500ms内是最合适的，1s左右也可以接受，到3s以上就有点不可接受</p><h2 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h2><p>每秒处理请求数量</p><h2 id="抓取Node端性能"><a href="#抓取Node端性能" class="headerlink" title="抓取Node端性能"></a>抓取Node端性能</h2><h2 id="优化对比性能"><a href="#优化对比性能" class="headerlink" title="优化对比性能"></a>优化对比性能</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在做页面性能优化的时候关注的重点一般是网络消耗，比如减少网络请求、降低资源大小等等，而优化JS代码执行时间其实也是一种非常不错的方式，尤其是
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
