<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Next.js+Egg.js配置 · 罗文迪的博客</title><meta name="description" content="Next.js+Egg.js配置 - biaodigit"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="罗文迪的博客"><link rel="alternate" href="/atom.xml" title="罗文迪的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/biaodigit" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://biaodigit.github.io/LeetCode/" target="_blank" class="nav-list-link">LEETCODE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Next.js+Egg.js配置</h1><div class="post-info">2020年1月7日</div><div class="post-content"><h2 id="Next-js简介"><a href="#Next-js简介" class="headerlink" title="Next.js简介"></a>Next.js简介</h2><p>Next.js作为<a href="https://reactjs.org/docs/create-a-new-react-app.html#nextjs" target="_blank" rel="noopener">React官方钦定</a>的SSR轻量级框架，有以下几个特性：</p>
<ul>
<li>开箱即用，支持0配置开发</li>
<li>支持约定式路由</li>
<li>支持自定义服务端路由，可以配合其他Node框架使用</li>
<li>渐进式babel和webpack配置</li>
<li>支持客户端渲染</li>
<li>社区活跃，团队不太监</li>
<li>对前端新技术支持较为全面，比如AMP、TypeScript、PWA、Serverless等</li>
</ul>
<p>在Nemo FE以React为主要开发框架的前提下SEO项目重构选择Next.js就非常合适</p>
<a id="more"></a>

<h2 id="Next-js自定义配置"><a href="#Next-js自定义配置" class="headerlink" title="Next.js自定义配置"></a>Next.js自定义配置</h2><p>官方文档在自定义服务端路由的例子中给出了一个demo，可以给后面和Egg.js配置提供参考性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createServer &#125; = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; parse &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">const</span> next = <span class="built_in">require</span>(<span class="string">'next'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> app = next(&#123; dev &#125;)</span><br><span class="line"><span class="keyword">const</span> handle = app.getRequestHandler()</span><br><span class="line"></span><br><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parsedUrl = parse(req.url, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname, query &#125; = parsedUrl</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pathname === <span class="string">'/a'</span>) &#123;</span><br><span class="line">      app.render(req, res, <span class="string">'/b'</span>, query)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/b'</span>) &#123;</span><br><span class="line">      app.render(req, res, <span class="string">'/a'</span>, query)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handle(req, res, parsedUrl)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).listen(<span class="number">3000</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt; Ready on http://localhost:3000'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的代码大概可以拆分成两个部分:<br></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> app = next(&#123; dev &#125;)</span><br><span class="line"><span class="keyword">const</span> handle = app.getRequestHandler()</span><br></pre></td></tr></table></figure>

<p>1.对next进行实例化，缓存环境变量以及一个处理页面资源请求的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.prepare().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2.当前期的实例和方法都准备好以后，下一步就是启动服务了，启动http服务之前先跑了一次<code>app.prepare</code>，而这个<code>app.prepare</code>是干什么用的呢，在这里可以先不急着去看prepare的源码，可以先去看看next官方脚手架是怎么跑起来的。</p>
<p>官方给出的命令配置如下：<br><img src="/2020/01/07/3/01.png" alt="01.png"><br>以<code>dev</code>为例，可以从next源码中找到对应的<code>cli/next-dev.ts</code>文件</p>
<blockquote>
<p>next-dev.ts</p>
</blockquote>
<p><img src="/2020/01/07/3/02.png" alt="02.png"><br>可以看到在<code>dev</code>启动命令同样调用了<code>app.prepare</code>这个方法，而前面那个<code>startServer</code>又是个什么东西，可以根据路径找到对应文件</p>
<blockquote>
<p>start-server.ts</p>
</blockquote>
<p><img src="/2020/01/07/3/03.png" alt="03.png"></p>
<p>看到这里就大概知道官方启动next的流程是先启动一个http服务，启动完后再去调用<code>app.prepare</code>方法，除了<code>dev</code>生产模式下的<code>start</code>也是同样流程，所以这个时候prepare内部是干什么的已经不需要去知道，源码怎么做这边自定义启动next就怎么做</p>
<p>至于是先创建http服务还是先跑<code>app.prepare</code>方法也不重要，只要在开始做路由匹配前都启动完成即可</p>
<h2 id="Egg-js自定义配置"><a href="#Egg-js自定义配置" class="headerlink" title="Egg.js自定义配置"></a>Egg.js自定义配置</h2><p>Egg.js自定义配置较简单，只需要在根目录新建一个<code>app.js</code>，调用<code>beforeStart</code>即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (app) =&gt; &#123;</span><br><span class="line">    app.beforeStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       ...      </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>beforeStart</code>定义</p>
<blockquote>
<p>所有的配置已经加载完毕,可以用来加载应用自定义的文件，启动自定义的服务</p>
</blockquote>
<h2 id="搭建思路"><a href="#搭建思路" class="headerlink" title="搭建思路"></a>搭建思路</h2><blockquote>
<p>本文采用的Next9.x版本进行配置，已成功进行上线验证</p>
</blockquote>
<p>Ok，在分析完Next.js和Egg.js的自定义配置过程后，下面开始思考下🤔怎么把这两个官方团队相互排斥的框架结合在一起做成自己想要的配置</p>
<p>先捋一下搭建思路：</p>
<ul>
<li>首先路由是由Egg控制而不是使用Next的约定式路由，因为契合SEO需求一个页面可能被多个路由使用，所以用Egg控制路由更合适</li>
<li>既然项目用Egg启动也就是Next需要自定义在Egg启动的时候实例化，实例化要做两件事情：<ul>
<li>1.自定义一个render方法然后挂载在上Egg上，因为View层渲染是由Next去完成，然后通过的Egg的Controller返回给客户端</li>
<li>2.上文提到Next有一个<code>getRequestHandler</code>的方法用于处理路由和静态文件，放到这里路由是不用处理因为这事是Egg做的，但是静态资源还是要由Next做的，所以也应该想办法把这个方法挂到Egg上</li>
</ul>
</li>
<li>考虑到SEO需求需要使用Google的<code>AMP</code>框架，鉴于之前使用Egg模版引擎<code>Nunjucks</code>在写H5页和AMP页的时候HTML和CSS都需要分开写&amp;&amp;打包，既然Next支持AMP，为了体现重构的价值争取用最少的代码实现一步到位</li>
</ul>
<p>大概就是这三点是整个搭建过程需要考虑的</p>
<h2 id="Egg-js-Next-js-Initialize-Combine"><a href="#Egg-js-Next-js-Initialize-Combine" class="headerlink" title="Egg.js+Next.js Initialize Combine"></a>Egg.js+Next.js Initialize Combine</h2><p>首先使用egg脚手架初始化项目</p>
<blockquote>
<p>egg-init [project] –type=simple</p>
</blockquote>
<p>按上面说的到的思路在Egg启动的时候对Next进行实例化，那么先来建一个<code>ssr.js</code>，对<code>next</code>的实例化主要分为3步：</p>
<ul>
<li><code>next</code>实例化，然后调用<code>prepare</code>方法</li>
<li>因为需要通过<code>next</code>生成<code>html模版</code>，已经不需要使用Egg的<code>render</code>方法，所以要自行封装<code>renderTsx</code>方法，方法内部调用<code>render</code>方法返回渲染好的<code>html模版</code></li>
<li>然后把<code>renderTsx</code>方法挂载到Egg的<code>ctx</code>上</li>
</ul>
<blockquote>
</blockquote>
<blockquote>
<p>server/ssr.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Application&#125; <span class="keyword">from</span> <span class="string">'egg'</span></span><br><span class="line"><span class="keyword">const</span> next = <span class="built_in">require</span>(<span class="string">'next'</span>)</span><br><span class="line"><span class="keyword">const</span> dev = process.env.NODE_ENV !== <span class="string">'production'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (app:Application) =&gt; &#123;</span><br><span class="line">  <span class="comment">// next实例化</span></span><br><span class="line">  <span class="keyword">const</span> nextServer = next(&#123; dev &#125;);</span><br><span class="line">  <span class="comment">// 缓存getRequestHander方法</span></span><br><span class="line">  <span class="keyword">const</span> requestHandler = nextServer.getRequestHandler();</span><br><span class="line">  <span class="comment">// 按照上面分析先调用prepare方法</span></span><br><span class="line">  <span class="keyword">await</span> nextServer.prepare();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> renderTsx = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// 调用nextServer的render方法，里面传入的page路径和参数都通过在Egg端传入</span></span><br><span class="line">      <span class="keyword">const</span> html = <span class="keyword">await</span> nextServer.render(</span><br><span class="line">          ctx.req,</span><br><span class="line">          ctx.res,</span><br><span class="line">          <span class="string">`/<span class="subst">$&#123;options.page&#125;</span>`</span>,</span><br><span class="line">          options.props</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 模版挂载到body上</span></span><br><span class="line">      ctx.body = html;</span><br><span class="line">      <span class="keyword">return</span> html</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用Object.defineProerty方法挂载renderTsx方法</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(app.context, <span class="string">'renderTsx'</span>, &#123;</span><br><span class="line">      writable: <span class="literal">false</span>,</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      value: renderTsx</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用Object.defineProerty方法挂载requestHandler方法，在Egg中间件调用</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(app.context, <span class="string">'requestHandler'</span>, &#123;</span><br><span class="line">      writable: <span class="literal">false</span>,</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      value: requestHandler</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Egg.js文档自定义Egg服务需要在根目录建一个<code>app.ts</code>，并要默认导出一个类，然后引入刚才在<code>ssr.ts</code>中封装的启动函数</p>
<blockquote>
<p>app.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Application &#125; <span class="keyword">from</span> <span class="string">'egg'</span></span><br><span class="line"><span class="keyword">const</span> SSR = <span class="built_in">require</span>(<span class="string">'./server/ssr'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app:Application</span>) =&gt;</span> &#123;</span><br><span class="line">    app.beforeStart(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">       <span class="keyword">await</span> SSR(app)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面说到<code>requestHandler</code>在挂载到<code>ctx</code>上后需要在中间件调用，为什么要在中间件调用呢，</p>
<p>通过阅读Next的源码分析了<code>getRequestHandler</code>调用的全过程，简单总结下调用的过程大概是：</p>
<ul>
<li>Next在启动Node服务<code>createServer</code>后会调用<code>getRequestHandler</code></li>
<li>调用后截取全部请求URL(这个URL不单指只在浏览器输入的，还包括其他静态脚本文件)，同时与内部的<code>Router</code>数组做一次匹配</li>
<li>如果匹配到对应的前缀比如<code>/_next/static/</code>后会回调<code>Router</code>中的<code>fn</code>方法，而这个<code>fn</code>做的事情不限于渲染页面、页面热更替等等</li>
</ul>
<p>既然要截取全部请求URL那放在中间件就再适合不过了，至于为什么要手动挂载到Egg的中间件上，原因也很简单，因为我们并没有启动Next内部的Node服务，所以要手动调用挂载这个方法</p>
<blockquote>
<p>middleware/next.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Application &#125; <span class="keyword">from</span> <span class="string">'egg'</span></span><br><span class="line"><span class="keyword">const</span> &#123; parse &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app: Application</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> isNextStatic = <span class="regexp">/\/_next\//</span>.test(ctx.url)</span><br><span class="line">        <span class="keyword">if</span> (isNextStatic) &#123;</span><br><span class="line">            <span class="keyword">const</span> reqeustUrl = parse(ctx.url, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">await</span> ctx.requestHandler(ctx.req, ctx.res, reqeustUrl)</span><br><span class="line">        &#125; &#123;</span><br><span class="line">            <span class="keyword">await</span> next()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>config</code>文件夹中配置<code>config.default.ts</code>文件，默认开启中间件</p>
<blockquote>
<p>config/config.default.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">appInfo: EggAppInfo</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  config.middleware = [<span class="string">'next'</span>]</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> &#123; ...config &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这里看官们应该会有一个疑问🤔️，为什么egg的自定义配置用的是<code>common.js</code>规范而不是<code>esmodule</code>规范，在我的<a href="https://biaodigit.github.io/2020/01/07/2/" target="_blank" rel="noopener">Next.js使用总结</a>文章中有总结原因，在这里就不再赘述，欢迎各位看官去看一看，说不定还有一些你现在使用Next.js的一些疑难杂症（手动斜眼。</p>
<p>至此Next.js+Egg.js配置已基本结束，楼主还是会一直持续关注Next.js的变化，顺便写一些Next.js源码解析文章，毕竟工欲善其事必先利其器，灵活运用一个框架了解其原理是必不可少的，所以敬请期待🎉🎉🎉</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/01/18/4/" class="prev">PREV</a><a href="/2020/01/07/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://yoursite.com">biaodigit</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>